# 核心

## 1. 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**
> 1. 代码区：存放函数体的二进制代码，由操作系统进行管理的
> 2. 全局区：存放全局变量和静态变量以及常量
> 3. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
> 4. 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

程序编译后，生成exe可执行程序，未执行之前分为代码区和全局区⬇️

- ### 代码区
  存放CPU执行的机器指令  
  代码区是**共享**的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可  
  代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令
- ### 全局区
  全局变量和静态变量存放在此  
  全局区还包含了常量区，字符串常量和其他常量(如const)也存放在此   
  **该区域的数据在程序结束后由操作系统释放**
    ```cpp
    // 全局变量
    int g_a = 10;
    int g_b = 10;
  
    // const修饰全局变量，全局常量
    const int c_g_a = 10;
    const int c_g_b = 10;
  
    int main() {
      // 普通局部变量
      int a = 10;
      int b = 10;
      
      // 静态变量
      static int s_a = 10;
      static int s_b = 10;
  
      // 字符串常量
      "hello world";
  
      // const修饰的变量
      const int c_l_a = 10;
      const int c_l_b = 10;
  
      cout << "局部变量a" << (int)&a; // 5961520
      cout << "局部变量b" << (int)&b; // 5961508
      cout << "全局变量g_a" << (int)&g_a; // 10272820
      cout << "全局变量g_b" << (int)&g_b; // 10272824
      cout << "静态变量s_a" << (int)&s_a; // 10272828
      cout << "静态变量s_b" << (int)&s_b; // 10272832
      cout << "字符串常量" << (int)&"hello world"; // 10263396
      cout << "全局常量c_g_a" << (int)&c_g_a; // 10264208
      cout << "全局常量c_g_b" << (int)&c_g_b; // 10264212
      cout << "局部常量c_l_a" << (int)&c_l_a; // 5961496
      cout << "局部常量c_l_b" << (int)&c_l_b; // 5961484
    }
    ```
  从上面的例子可以很明显的看出，```局部常量```和```局部变量```的地址很接近，因为都是局部修饰的，所以都不在```全局区```。  
  而全局区包括了```全局变量```、```静态变量```、```字符串常量```和```全局常量```
- ### 栈区
  由编译器自动分配释放，存放函数的参数值，局部变量等。  
  注意⚠️不要返回局部变量等地址，因为栈区开辟的数据由编译器自动释放。
- ### 堆区
  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收  
  在C++中主要利用```new```在堆区开辟内存  
  手动释放利用操作符```delete```
  ```cpp
  int *func() {
    // 利用new关键字 可以将数据开辟到堆区
    // 指针本质也是局部变量，保存在栈区，❗️指针保存到数据是放在堆区
    int *p = new int(10); // new返回到是该数据类型到指针
    int *arr = new int[10]; // 创建数组
    return p;
  }
  
  int main() {
    int *p = func();
    cout << *p; // 10
  
    delete p;
    delete[] arr; // 释放数组的时候要加[]
    cout << *p; // 内存已经释放，再次调用会出现异常❌
    return 0;
  }
  ```

## 2. 引用

基本语法：数据类型 &别名 = 原名

  ```cpp
  int a = 10;
  int &b = a; // b也有了操作地址a的权限
  ```

注意事项⚠️：  
引用必须初始化```int &b;❌```  
引用一旦初始化之后不得再更改引用，比如再次```int &c = a;```