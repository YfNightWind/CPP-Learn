# 核心

## 1. 内存分区模型

C++程序在执行时，将内存大方向划分为**4个区域**
> 1. 代码区：存放函数体的二进制代码，由操作系统进行管理的
> 2. 全局区：存放全局变量和静态变量以及常量
> 3. 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
> 4. 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

程序编译后，生成exe可执行程序，未执行之前分为代码区和全局区⬇️

- ### 代码区
  存放CPU执行的机器指令  
  代码区是**共享**的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可  
  代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令
- ### 全局区
  全局变量和静态变量存放在此  
  全局区还包含了常量区，字符串常量和其他常量(如const)也存放在此   
  **该区域的数据在程序结束后由操作系统释放**
    ```cpp
    // 全局变量
    int g_a = 10;
    int g_b = 10;
  
    // const修饰全局变量，全局常量
    const int c_g_a = 10;
    const int c_g_b = 10;
  
    int main() {
      // 普通局部变量
      int a = 10;
      int b = 10;
      
      // 静态变量
      static int s_a = 10;
      static int s_b = 10;
  
      // 字符串常量
      "hello world";
  
      // const修饰的变量
      const int c_l_a = 10;
      const int c_l_b = 10;
  
      cout << "局部变量a" << (int)&a; // 5961520
      cout << "局部变量b" << (int)&b; // 5961508
      cout << "全局变量g_a" << (int)&g_a; // 10272820
      cout << "全局变量g_b" << (int)&g_b; // 10272824
      cout << "静态变量s_a" << (int)&s_a; // 10272828
      cout << "静态变量s_b" << (int)&s_b; // 10272832
      cout << "字符串常量" << (int)&"hello world"; // 10263396
      cout << "全局常量c_g_a" << (int)&c_g_a; // 10264208
      cout << "全局常量c_g_b" << (int)&c_g_b; // 10264212
      cout << "局部常量c_l_a" << (int)&c_l_a; // 5961496
      cout << "局部常量c_l_b" << (int)&c_l_b; // 5961484
    }
    ```
  从上面的例子可以很明显的看出，```局部常量```和```局部变量```的地址很接近，因为都是局部修饰的，所以都不在```全局区```。  
  而全局区包括了```全局变量```、```静态变量```、```字符串常量```和```全局常量```
- ### 栈区
  由编译器自动分配释放，存放函数的参数值，局部变量等。  
  注意⚠️不要返回局部变量等地址，因为栈区开辟的数据由编译器自动释放。
- ### 堆区
  由程序员分配释放，若程序员不释放，程序结束时由操作系统回收  
  在C++中主要利用```new```在堆区开辟内存  
  手动释放利用操作符```delete```
  ```cpp
  int *func() {
    // 利用new关键字 可以将数据开辟到堆区
    // 指针本质也是局部变量，保存在栈区，❗️指针保存到数据是放在堆区
    int *p = new int(10); // new返回到是该数据类型到指针
    int *arr = new int[10]; // 创建数组
    return p;
  }
  
  int main() {
    int *p = func();
    cout << *p; // 10
  
    delete p;
    delete[] arr; // 释放数组的时候要加[]
    cout << *p; // 内存已经释放，再次调用会出现异常❌
    return 0;
  }
  ```

## 2. 引用

基本语法：数据类型 &别名 = 原名

  ```cpp
  int a = 10;
int &b = a; // b也有了操作地址a的权限
  ```

注意事项⚠️：  
引用必须初始化```int &b;❌```  
引用一旦初始化之后不得再更改引用，比如再次```int &c = a;```

- ### 引用传递:

  ```cpp 
  void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp; 
  }
  
  int main() {
    int a = 10;
    int b = 20;
    swap(a, b); // 结果交换了
  }
  ```
- ### 引用做函数的返回值:
  注意事项⚠️：  
  1.不要返回局部变量的引用
  ```cpp
  int &test() {
    int a = 10;
    return a; 
  }
  
  int main() {
    int &ref = test();
    cout << ref; // 10，因为编译器做了保留
    cout << ref; // 结果❌，因为a的内存已经释放
    return 0;
  }
  ```
  2.函数的调用可以作为左值存在
  ```cpp
  int &test() {
    static int a = 10;
    return a; 
  }
  
  int main() {
    int &ref = test();
    cout << ref; 
    cout << ref; // 这里就是10了，因为static存放在全局区
    
    test() = 1000; // 如果函数的返回值是引用，这个函数调用可以作为左值❗️
    cout << ref; // 1000，因为是引用，相当于做了a = 1000的操作，ref相当于a的别名
    return 0;
  }
  ```
- ### 引用的本质：
  **本质在C++内部实现的是一个指针常量**
  ```cpp
  // 发现是引用，转换为int *const ref = &a;
  void func(int &ref) {
    ref = 100; // ref是引用，转换为*ref = 100
  }
  
  int main() {
    int a = 10;
    
    // 自动转换为 int *const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int &ref = a;
    ref = 20; // 内部发现ref是引用，自动帮我们转换为：*ref = 20;
  
    cout << a << endl;
    cout << ref << endl;
  
    func(a);
    return 0;
  }
  ```
- ### 常量引用:
  **作用**：主要是来修饰形参，防止误操作  
  `const int &ref = 10;`相当于`int temp = 10; const int &ref = temp;`

## 3. 函数提高

关于函数的默认参数，有一点需要注意：声明和实现只能有一个有默认参数

- ### 函数重载
  **作用**：提高复用性  
  **满足条件**：
    - 同一个作用域下
    - 函数名称相同
    - 函数参数**类型不同** or **个数不同** or **顺序不同**